// Package hashdir will compare two directory hashes and
// perform an action on the outcome. It is intended to be used
// in a GitHub action.
package hashdir

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

// ReadReadChecksum accepts a string defining the name of a checksum file.
// This file contains a namespace name and its sha256 hash. Both of these
// will be returned as a string.
func ReadChecksum(f string) (userHash, namespace string) {
	file, err := os.Open(f)
	if err != nil {
		fmt.Println(err)
	}

	defer file.Close()

	scanner := bufio.NewScanner(file)
	scanner.Split(bufio.ScanLines)

	var lines []string
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}

	namespace = lines[1]
	userHash = lines[2]

	return
}

// SingleNamespace ensures that a pull request contains only one namespace.
// A GitHub action will create a file containing all amended files in a pull request.
// These values are added to an array and then parsed, removing any duplicates.
// If more than one namespace is found, the function returns false.
func SingleNamespace(ns string, base string) (v bool) {
	// This file is generated by a GitHub action.
	jsonFile := os.Getenv("HOME") + "/files.json"
	var arr []string
	var s []string

	f, err := ioutil.ReadFile(jsonFile)
	if err != nil {
		fmt.Println(err)
	}

	err = json.Unmarshal([]byte(f), &arr)
	if err != nil {
		fmt.Println(err)
	}

	for _, val := range arr {
		if strings.Contains(val, base) {
			res := strings.Split(val, "/")
			// an example string would be namespaces/live-1../mynamespace
			s = append(s, res[2])
		}
	}

	s = removeDuplicates(s)

	if len(s) == 1 {
		v = true
	} else {
		fmt.Println("There are", len(s), "namespaces in this PR:", s)
	}

	return
}

// removeDuplicates takes a slice of strings and checks to see if any
// values have been duplicated. Duplicates occur when a number of files
// within the same namespace have been amended. It returns a slice of
// strings with the duplicates removed.
func removeDuplicates(elements []string) []string {
	// Use map to record duplicates as we find them.
	encountered := map[string]bool{}
	result := []string{}

	for v := range elements {
		if encountered[elements[v]] == true {
			// Do not add duplicate.
		} else {
			// Record this element as an encountered element.
			encountered[elements[v]] = true
			// Append to result slice.
			result = append(result, elements[v])
		}
	}
	// Return the new slice.
	return result
}

// HashesMatch takes two strings and returns true if they match.
func HashesMatch(prHash, gaHash string) (match bool) {
	if prHash == gaHash {
		match = true
	}

	return
}

// CreateArtifact creates a file in the executing directory. This
// file acts as a trigger for downstream events.
func CreateArtifact(s string) error {
	m := []byte(s)
	err := ioutil.WriteFile(".approved", m, 0644)
	if err != nil {
		fmt.Println(err)
	}

	return err
}
