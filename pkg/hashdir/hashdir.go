// Package hashdir will compare two directory hashes and
// perform an action on the outcome. It is intended to be used
// in a GitHub action.
package hashdir

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

// ReadReadChecksum accepts a string defining the name of a checksum file.
// This file contains a namespace name and its sha256 hash. Both of these
// will be returned as a string.
func ReadChecksum(f string) (userHash, namespace string) {
	// If the checksum file doesn't exit, exit cleanly ensuring GitHub
	// actions remain green.
	if _, err := os.Stat(f); os.IsNotExist(err) {
		fmt.Println("Checksum file doesn't exist. Exiting")
		os.Exit(0)
	}

	file, err := os.Open(f)
	if err != nil {
		fmt.Println(err)
	}

	defer file.Close()

	scanner := bufio.NewScanner(file)
	scanner.Split(bufio.ScanLines)

	var lines []string
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}

	namespace = lines[1]
	userHash = lines[2]

	return
}

// ValidateNamespace creates a collection of namespaces changed in a given PR.
// It then checks if the namespace in the .checksum file matches a namespace in the PR.
// If all of these conditions pass and only one namespace is changed, the function returns true.
func ValidateNamespace(ns, base string) (bool, error) {
	// Creates a collection of changed namespaces.
	s, err := createArray(ns, base)
	if err != nil {
		fmt.Println("Error reading changed files in this PR")
		return false, err
	}

	// Checks if the namespace is in the .checksum file.
	r := checkNamespaceChange(ns, s)
	if !r {
		fmt.Println("Was expecting", ns, "but received", s)
		return false, err
	}

	// Checks if there is only one namespace per PR.
	t := checkSingleNamespace(s)
	if !t {
		fmt.Println("There are", len(s), "namespaces in this PR:", s)
		return false, err
	}

	return true, nil
}

// createArray uses a file generated by an upstream GitHub action to create a collection
// of strings that define which directories/files have changes. This collection is then
// passed for deduplication and then returns its output.
func createArray(ns, base string) (s []string, err error) {
	// This file is generated by a GitHub action.
	jsonFile := os.Getenv("HOME") + "/files.json"
	var arr []string

	f, err := ioutil.ReadFile(jsonFile)
	if err != nil {
		return arr, err
	}

	err = json.Unmarshal([]byte(f), &arr)
	if err != nil {
		return arr, err
	}

	for _, val := range arr {
		if strings.Contains(val, base) {
			res := strings.Split(val, "/")
			// an example string would be namespaces/live-1../mynamespace
			s = append(s, res[2])
		}
	}

	s = removeDuplicates(s)

	return s, nil
}

// checkNamespaceChange is passed a namespace and a collection of strings containing
// directories/files changed by a PR. It loops over this collection and confirms if
// the namespace in .checksum matches with one of its values.
func checkNamespaceChange(n string, arr []string) (b bool) {
	for _, v := range arr {
		if v == n {
			b = true
		}
	}
	return
}

// checkSingleNamespace is passed a collection of strings and returns true if there is
// only namespace in its value, otherwise it returns false.
func checkSingleNamespace(arr []string) (v bool) {
	if len(arr) == 1 {
		v = true
	}
	return
}

// removeDuplicates takes a slice of strings and checks to see if any
// values have been duplicated. Duplicates occur when a number of files
// within the same namespace have been amended. It returns a slice of
// strings with the duplicates removed.
func removeDuplicates(elements []string) []string {
	// Use map to record duplicates as we find them.
	encountered := map[string]bool{}
	result := []string{}

	for v := range elements {
		if encountered[elements[v]] == true {
			// Do not add duplicate.
		} else {
			// Record this element as an encountered element.
			encountered[elements[v]] = true
			// Append to result slice.
			result = append(result, elements[v])
		}
	}
	// Return the new slice.
	return result
}

// HashesMatch takes two strings and returns true if they match.
func HashesMatch(prHash, gaHash string) (match bool) {
	if prHash == gaHash {
		match = true
	}

	return
}
