# Cloud Platform Directory Hash

## Table of Contents
- [Overview]
- [Installation]
- [Usage]
- [Develop]

## Overview

### Problem

At present the [cloud-platform-environments] repository requires a Cloud Platform engineer to manually review and approve every pull request. A large portion of these pull requests are generated by scripts or the [cloud-platform-cli] tool and take time and effort to review. 

### Solution

Using a combination of the [cloud-platform-cli], a [GitHub action] and the Go application in this repository, create a workflow that would automatically approve a pull request that is deemed sufficiently standard. In the early stages of the development of this tool, it was accepted that standard in this case referred to a namespace created by the [cloud-platform-cli] tool, using the command `cloud-platform-cli create environment`. 

This diagram shows a simple workflow to address the problem:

![workflow diagram](https://raw.githubusercontent.com/ministryofjustice/cloud-platform-directory-hash/main/docs/workflow2.png)

1. It was decided very early on, the best way to ensure the integrity of a newly created namespace was to form a hash of its contents. This hash would then need to be passed to a PR and some further logic would apply to confirm its validity. Because the Cloud Platform team have already created a command line interface (CLI) tool to template onboarding to the platform, it became evident that the initial hash upon creation should be performed by this tool. The hash would then be added to the PR via an artefact in the root of the [cloud-platform-environment] repository.

2. Upon raising a pull request a [GitHub action] would trigger. This action would simply checkout the relevant branch, perform a check and display its output. It was extremely important not to fail the GitHub action if the check did not pass. This is due to the nature of GitHub actions. Upon failure (an exit 1 as an example) GitHub wil display a hideous red "x" next to all failed commits, and as the majority of pull requests would not auto-apply, this seemed unnecessary.

3. The GitHub action calls the application in this repository called `directory-hash`. This creates a new hash of the namespace directory outlined in the pull request. It then performs two checks:
- Does the PR contain only one namespace?
- Does the new namespace hash match the hash passed via the artefact?

4. Depending on the result of 3, the `directory-hash` application will inform the GitHub action through the creation of another artefact. It does this as there is no comfortable condition for GitHub action to approve or deny. If stage three is true, a .approved file is created and the PR will be approved. If it's false, the file will not be completed.

5. The GitHub action can now approve or ignore the pull request.

6. The PR is approved or ignored by the GitHub action robot user. 

7. If the preceding steps are true, the user can merge the code into main. However, a Cloud Platform engineer will need to review if they're false.



[create a repository]: https://github.com/ministryofjustice/template-repository/generate
